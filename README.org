* Ping application

This application is a POC, implementing the following behaviour using Apache Kafka as broker:

#+begin_src plantuml :file architecture.svg
  @startuml
  left to right direction
  title Ping Architecture

  !include <cloudinsight/kafka>
  queue "Apache Kafka" <<$kafka>> {
      queue ping
      queue pong
      ping -[hidden]l-> pong
  }

  component "Ping Client" {
      together {
	  component "producer" as ping_producer
	  component "consumer" as ping_consumer
      }
      component "stm" as ping_stm
      ping_stm --> ping_producer: 1
      ping_producer --> ping_stm: 2
      ping_stm --> ping_consumer: 3
  }
  component "Ping Server" {
      together {
	  component "consumer" as pong_consumer
	  component "producer" as pong_producer
      }
      component "stm" as pong_stm
      pong_consumer ---> pong_stm: 1
      pong_stm --> pong_producer: 2
  }

  ping_producer --> ping: Ping
  ping --> pong_consumer: Ping
  pong <-- pong_producer: Pong
  ping_consumer <-- pong: Pong
  @enduml
#+end_src

#+RESULTS:
[[file:architecture.svg]]

Both the client and the server component are implemented in Rust using the [[https://github.com/vnermolaev/oblivious-state-machine][Oblivious state machine]] and [[https://github.com/kafka-rust/kafka-rust][kafka-rust]] libraries.

* Setup development environment

The development environment is setup using ~docker-compose~, and consists of a Kafka server, including zookeeper, kafka-ui, schemaregistry and kafka-connect.

#+begin_src bash
  docker-compose up
#+end_src

This will download and start all the necessary services. It will also create the topics that needed for this POC.

You can Contact Kafka UI at: http://localhost:8080/

* Ping Client

The Ping client is implemented as a single-shot CLI application.

In order to run the Ping component with logging, set ~RUST_LOG~, e.g.:

#+begin_src bash
  RUST_LOG=trace cargo run --bin ping
#+end_src

Or spawn many concurrent tasks:

#+begin_src bash
  cargo build --release
  for i in {0..31};
  do
      RUST_LOG=info target/release/ping &
  done
#+end_src

** Ping state machine

#+begin_src plantuml :file ping.svg
  [*] -> SendingPing: correlation_id
  SendingPing -> ListeningForPong
  ListeningForPong -> [*]: Pong(correlation_id)
#+end_src

#+RESULTS:
[[file:ping.svg]]

* Ping Server

The Ping server is implemented using ~tokio~. For each incoming message, a new task is spawned, that will execute the STM.

In order to run the Pong component with logging, set ~RUST_LOG~, e.g.:

#+begin_src bash
  RUST_LOG=info cargo run --bin pong
#+end_src

** Pong state machine

#+begin_src plantuml :file pong.svg
  [*] -> ListeningForPing
  ListeningForPing -> SendingPong: Ping
  SendingPong -> SentPong: PongSent
  SentPong -> [*]
#+end_src

#+RESULTS:
[[file:pong.svg]]

** Making this a server

The Pong component is implemented as a server, for every incoming
message on the ~ping~ queue, it parses the message and spanws a new
tokio task that executes the oblivious state machine.

#+begin_src plantuml :file pong-server.svg
  [kafka consumer] -> [pong stm]: spawn tokio task
#+end_src

#+RESULTS:
[[file:pong-server.svg]]

The disadvantage of this approach it that this will only work for STMs
that depend on a single kafka message. In order to make this work for
a STM that depends on multiple kafka messages to advance the STM, we
should have a correlation id in the messages, and open a channel for
each stm. Then newer messages can be sent to the correct channel based
on the correlation id.

* TODO

- Use ~apache-avro = { version = "X.Y.Z", features = ["derive"] }~ instead of JSON, and publish schema to schemaregistry.
- Create topics from client/server?
